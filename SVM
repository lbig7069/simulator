<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>인공지능 수학: 서포트 벡터 머신 탐구</title>
    <!-- Tailwind CSS (스타일링) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 폰트 설정 -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap');
        body { font-family: 'Noto Sans KR', sans-serif; }
        
        /* 커스텀 스타일 */
        .separator-line {
            background-color: #374151; /* Slate-700 */
            height: 3px;
        }
        .margin-line {
            border: 2px dashed #9ca3af; /* Gray-400 */
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">

    <!-- 상단 네비게이션 -->
    <nav class="bg-white border-b border-slate-200 sticky top-0 z-50">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between h-16">
                <div class="flex items-center gap-3">
                    <div class="bg-red-600 text-white p-2 rounded-lg">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
                        </svg>
                    </div>
                    <span class="font-bold text-xl text-slate-900">AI Math: 서포트 벡터 머신 시뮬레이터</span>
                </div>
                <div class="flex items-center">
                    <span class="text-sm text-slate-500 bg-slate-100 px-3 py-1 rounded-full">지도 학습 심화</span>
                </div>
            </div>
        </div>
    </nav>

    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        
        <!-- 시뮬레이터 메인 섹션 -->
        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8 mb-12">
            
            <!-- 왼쪽: 인터랙티브 캔버스 (8칸 차지) -->
            <div class="lg:col-span-8 space-y-4">
                <div class="bg-white rounded-2xl shadow-sm border border-slate-200 p-1 relative overflow-hidden group">
                    <canvas id="mainCanvas" class="w-full h-[400px] md:h-[500px] bg-white cursor-crosshair touch-none"></canvas>
                    
                    <!-- 안내 메시지 오버레이 -->
                    <div id="guideMsg" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center pointer-events-none transition-opacity duration-500 opacity-100">
                        <div class="bg-red-50/90 text-red-700 px-6 py-4 rounded-xl shadow-lg border border-red-100 backdrop-blur-sm">
                            <p class="font-bold text-lg mb-1">👆 화면을 클릭해 학습 데이터 (클래스 A/B)를 추가하세요!</p>
                            <p class="text-sm">A와 B를 **선형으로 분리 가능**하도록 데이터를 찍어보세요.</p>
                        </div>
                    </div>

                    <!-- 클래스 A/B 전환 버튼 -->
                    <div class="absolute top-4 left-4 z-10">
                        <div class="flex items-center space-x-2 bg-white p-3 rounded-xl shadow-lg border border-slate-200">
                            <span class="text-sm font-semibold text-slate-700">추가할 데이터 클래스:</span>
                            <button id="btnToggleClass" class="flex items-center gap-2 px-3 py-1.5 rounded-lg font-bold transition-colors shadow">
                                <span id="currentClassDisplay" class="text-white text-base">A</span>
                            </button>
                        </div>
                    </div>
                </div>
                
                <div class="flex justify-between items-center text-sm text-slate-500 px-2">
                    <p id="statusMessage">상태: 데이터 입력 중...</p>
                    <button id="btnClear" class="text-red-500 hover:text-red-700 hover:underline flex items-center gap-1 transition">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                        </svg>
                        모든 데이터 지우기
                    </button>
                </div>
            </div>

            <!-- 오른쪽: 컨트롤 패널 (4칸 차지) -->
            <div class="lg:col-span-4 space-y-6">
                
                <!-- SVM 실행 및 결과 -->
                <div class="bg-white rounded-2xl shadow-lg border border-red-100 p-6 relative overflow-hidden">
                    <div class="absolute top-0 left-0 w-2 h-full bg-red-500"></div>
                    <h3 class="text-sm font-bold text-slate-400 uppercase tracking-wider mb-2">SVM Control & Result</h3>
                    
                    <button id="btnRunSVM" class="w-full bg-slate-900 hover:bg-slate-800 text-white font-bold py-3 px-4 rounded-xl shadow-md transform active:scale-95 transition-all flex items-center justify-center gap-2 mt-4" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-yellow-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.418A9.954 9.954 0 0012 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10c0-1.77-.45-3.46-1.282-4.918z" />
                        </svg>
                        최대 마진 경계선 계산 및 시각화
                    </button>

                    <div id="resultDetails" class="text-sm text-slate-600 mt-4 pt-4 border-t border-slate-100 space-y-2">
                        <p><span class="font-bold text-red-700">핵심 원리:</span> 경계선 양쪽에 있는 **서포트 벡터**들 사이의 거리를 최대화합니다.</p>
                        <p class="font-bold text-slate-800">최대 마진: <span id="dispMargin" class="font-mono text-lg text-slate-900">N/A</span></p>
                        <p class="font-bold text-slate-800">서포트 벡터 수: <span id="dispSVCount" class="font-mono text-lg text-slate-900">0</span></p>
                    </div>
                </div>

                <!-- 개념 설명 카드 -->
                <div class="bg-white rounded-2xl shadow-sm border border-slate-200 p-6 space-y-4">
                    <h3 class="font-bold text-slate-700 border-b pb-2">SVM 핵심 구성 요소</h3>

                    <div class="text-sm space-y-2">
                        <p><span class="font-bold text-violet-600">하이퍼플레인 (결정 경계):</span> 두 클래스를 나누는 가장 이상적인 선입니다. 모든 점들이 이 선에서 가능한 한 멀리 떨어지도록 최적화됩니다.</p>
                        <p><span class="font-bold text-teal-600">마진 (Margin):</span> 하이퍼플레인과 가장 가까운 데이터 점(서포트 벡터) 사이의 거리입니다. SVM은 이 마진을 최대화합니다.</p>
                        <p><span class="font-bold text-red-600">서포트 벡터 (Support Vector, SV):</span> 마진 경계선에 딱 붙어 있는, 분류에 **가장 큰 영향**을 미치는 데이터 점들입니다. SVM은 이 점들만 사용하여 경계선을 정의합니다.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- 하단: 학습 자료 (개념 설명) -->
        <div class="border-t border-slate-200 pt-12">
            <h2 class="text-2xl font-bold text-slate-800 mb-6">📚 SVM의 목표: 마진 최대화</h2>
            <div class="grid md:grid-cols-3 gap-6">
                <!-- 카드 1: 마진 -->
                <div class="bg-white p-6 rounded-xl border border-slate-200 hover:shadow-md transition">
                    <div class="w-10 h-10 bg-teal-100 rounded-lg flex items-center justify-center mb-4 text-teal-600 font-bold text-xl">M</div>
                    <h3 class="font-bold text-lg mb-2">최대 마진의 의미</h3>
                    <p class="text-slate-600 text-sm leading-relaxed">
                        최대 마진 경계선은 새로운 데이터가 들어왔을 때 가장 <span class="font-bold">강력한 일반화 성능</span>을 보여줍니다. 즉, 새로운 데이터를 실수 없이 분류할 가능성이 가장 높은 경계선입니다.
                    </p>
                </div>
                <!-- 카드 2: 노이즈 대응 -->
                <div class="bg-white p-6 rounded-xl border border-slate-200 hover:shadow-md transition">
                    <div class="w-10 h-10 bg-violet-100 rounded-lg flex items-center justify-center mb-4 text-violet-600 font-bold text-xl">🧩</div>
                    <h3 class="font-bold text-lg mb-2">비선형과 커널 트릭</h3>
                    <p class="text-slate-600 text-sm leading-relaxed">
                        실제 데이터는 선형으로 분리되지 않는 경우가 많습니다. SVM은 **커널 트릭**을 사용하여 데이터를 고차원 공간으로 매핑함으로써, 비선형 문제도 선형으로 분리할 수 있게 만듭니다. (본 시뮬레이터는 2D 선형만 다룹니다.)
                    </p>
                </div>
                <!-- 카드 3: 서포트 벡터의 영향 -->
                <div class="bg-white p-6 rounded-xl border border-slate-200 hover:shadow-md transition">
                    <div class="w-10 h-10 bg-red-100 rounded-lg flex items-center justify-center mb-4 text-red-600 font-bold text-xl">🎯</div>
                    <h3 class="font-bold text-lg mb-2">서포트 벡터의 힘</h3>
                    <p class="text-slate-600 text-sm leading-relaxed">
                        경계선은 오직 서포트 벡터에 의해서만 결정됩니다. 마진 바깥에 있는 점들을 추가하거나 이동해도 경계선은 <span class="font-bold">변하지 않습니다.</span> 직접 시뮬레이터에서 확인해보세요.
                    </p>
                </div>
            </div>
        </div>
        

    </main>

    <footer class="bg-slate-900 text-slate-400 py-8 mt-12">
        <div class="max-w-7xl mx-auto px-4 text-center">
            <p class="mb-2">AI Education Project - Support Vector Machine</p>
            <p class="text-xs">HTML5 Canvas & JavaScript | No External Libraries Required</p>
        </div>
    </footer>

    <!-- 스크립트 -->
    <script>
        // 전역 범위 오염을 방지하기 위해 IIFE(즉시 실행 함수)로 감쌉니다.
        (function() {
            // --- 전역 변수 (함수 내부에서만 유효) ---
            const canvas = document.getElementById('mainCanvas');
            const ctx = canvas.getContext('2d');
            const guideMsg = document.getElementById('guideMsg');

            // SVM 상태
            let dataPoints = []; // {x, y, class}
            let currentClass = 'A'; // 'A' 또는 'B'
            let svmResult = {
                w: { x: 0, y: 0 }, // weight vector
                b: 0,              // bias
                supportVectors: [],
                margin: 0
            };
            
            // 좌표 설정 (논리적 좌표 -10 ~ 10)
            const VIEW_RANGE = 10;
            let scaleX, scaleY, originX, originY;

            // UI 요소
            const ui = {
                btnToggleClass: document.getElementById('btnToggleClass'),
                currentClassDisplay: document.getElementById('currentClassDisplay'),
                btnRunSVM: document.getElementById('btnRunSVM'),
                btnClear: document.getElementById('btnClear'),
                statusMessage: document.getElementById('statusMessage'),
                dispMargin: document.getElementById('dispMargin'),
                dispSVCount: document.getElementById('dispSVCount'),
            };

            // 클래스 색상
            const CLASS_COLORS = {
                'A': { bg: '#8b5cf6', ring: '#a78bfa', label: 1 }, // Violet-500
                'B': { bg: '#2dd4bf', ring: '#5eead4', label: -1 } // Teal-400
            };

            // --- 초기화 ---
            function init() {
                resize();
                window.addEventListener('resize', resize);
                
                // 초기 클래스 버튼 스타일 설정
                updateClassButton();

                // 이벤트 리스너 등록
                canvas.addEventListener('pointerdown', handleCanvasClick);
                
                ui.btnToggleClass.addEventListener('click', toggleCurrentClass);
                ui.btnRunSVM.addEventListener('click', calculateSVM);
                
                ui.btnClear.addEventListener('click', () => {
                    dataPoints = [];
                    resetSVMResult();
                    updateUI();
                    guideMsg.style.opacity = '1';
                    draw();
                });
                
                updateUI();
                draw();
            }

            // --- 화면 크기 조정 ---
            function resize() {
                const parent = canvas.parentElement;
                canvas.width = parent.clientWidth;
                canvas.height = parent.clientHeight || 500;
                
                originX = canvas.width / 2;
                originY = canvas.height / 2;
                
                // 좌표 스케일 설정
                const minDim = Math.min(canvas.width, canvas.height);
                scaleX = (minDim - 60) / (VIEW_RANGE * 2); 
                scaleY = (minDim - 60) / (VIEW_RANGE * 2);
                
                draw();
            }

            // --- 좌표 변환 ---
            const toScreen = (x, y) => ({
                x: originX + x * scaleX,
                y: originY - y * scaleY
            });
            
            const toLogical = (sx, sy) => ({
                x: (sx - originX) / scaleX,
                y: -(sy - originY) / scaleY
            });

            // --- 선형 대수 및 기하학 함수 ---
            
            // 유클리드 거리 제곱
            function distSq(p1, p2) {
                return Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2);
            }
            
            // 유클리드 거리
            function dist(p1, p2) {
                return Math.sqrt(distSq(p1, p2));
            }

            // 벡터 내적
            function dot(v1, v2) {
                return v1.x * v2.x + v1.y * v2.y;
            }

            // 벡터 길이 (놈)
            function norm(v) {
                return Math.sqrt(dot(v, v));
            }
            
            // --- SVM 로직 (단순 선형 분리 가능 데이터에 대해) ---
            
            function resetSVMResult() {
                svmResult = {
                    w: { x: 0, y: 0 },
                    b: 0,
                    supportVectors: [],
                    margin: 0
                };
            }

            function calculateSVM() {
                // 최소 A 1개, B 1개 필요
                const classA = dataPoints.filter(p => p.class === 'A');
                const classB = dataPoints.filter(p => p.class === 'B');
                
                if (classA.length < 1 || classB.length < 1) {
                    // alert 대신 콘솔 메시지 또는 커스텀 메시지 박스를 사용해야 하지만, 
                    // 이 시뮬레이터에서는 편의상 그대로 둡니다.
                    // 실제 환경에서는 사용자 정의 모달 UI를 사용해야 합니다.
                    console.error("최소한 A 클래스 1개와 B 클래스 1개의 데이터가 필요합니다.");
                    return;
                }
                
                // 1. 최단 거리 쌍 찾기 (서포트 벡터 후보)
                // 이 시뮬레이터에서는 가장 가까운 두 점(A 하나, B 하나)을 서포트 벡터로 가정하고 경계선을 만듭니다.
                // 이는 실제 SVM의 복잡한 최적화 과정의 결과를 단순화하여 보여줍니다.
                let min_d_sq = Infinity;
                let svA = null;
                let svB = null;

                for (const pA of classA) {
                    for (const pB of classB) {
                        const dSq = distSq(pA, pB);
                        if (dSq < min_d_sq) {
                            min_d_sq = dSq;
                            svA = pA;
                            svB = pB;
                        }
                    }
                }
                
                if (!svA || !svB) {
                    ui.statusMessage.innerText = "오류: 데이터 쌍을 찾을 수 없습니다.";
                    return;
                }

                // 2. 가중치 벡터 w 계산 (두 SV를 잇는 벡터와 평행)
                // w는 두 SV의 벡터 차이
                const w_temp = {
                    x: svA.x - svB.x,
                    y: svA.y - svB.y
                };
                
                // 실제 w 벡터의 놈은 1/Margin 이지만, 여기서는 경계선 위치만 계산하면 되므로 정규화는 생략
                svmResult.w = w_temp; 
                
                // 3. 편향 b 계산 (경계선이 두 SV의 중간을 지나도록 설정)
                // 하이퍼플레인은 두 서포트 벡터의 중점 (Midpoint)을 지나야 합니다.
                // Midpoint M = (svA + svB) / 2
                const midPoint = {
                    x: (svA.x + svB.x) / 2,
                    y: (svA.y + svB.y) / 2
                };
                
                // w * x + b = 0, 따라서 b = - (w * midPoint)
                svmResult.b = -dot(svmResult.w, midPoint);
                
                // 4. 마진 계산
                // 마진 = 1 / ||w||. 여기서 ||w|| = norm(svA - svB)
                // 전체 마진 (양쪽 마진 거리의 합) = ||svA - svB|| = distance(svA, svB)
                const full_margin = dist(svA, svB);
                svmResult.margin = full_margin / 2; // 한쪽 마진 거리

                // 5. 서포트 벡터 업데이트
                svmResult.supportVectors = [svA, svB];
                
                // 6. 결과 시각화
                updateUI('success');
                draw();
            }
            
            // --- UI 업데이트 함수 ---
            
            function updateClassButton() {
                const color = CLASS_COLORS[currentClass].bg;
                ui.btnToggleClass.style.backgroundColor = color;
                ui.currentClassDisplay.innerText = currentClass;
            }
            
            function toggleCurrentClass() {
                currentClass = (currentClass === 'A') ? 'B' : 'A';
                updateClassButton();
            }

            function updateUI(status) {
                const pointCount = dataPoints.length;
                
                if (pointCount < 2) {
                    ui.btnRunSVM.disabled = true;
                    ui.statusMessage.innerText = "상태: 데이터 입력 중 (최소 2개 필요)";
                } else {
                    ui.btnRunSVM.disabled = false;
                    ui.statusMessage.innerText = "상태: 데이터 입력 완료. SVM 계산 대기 중.";
                }

                if (status === 'success') {
                    ui.statusMessage.innerText = "상태: 최대 마진 경계선 계산 완료";
                    ui.dispMargin.innerText = (svmResult.margin * 2).toFixed(3) + ' (전체 마진)';
                    ui.dispSVCount.innerText = svmResult.supportVectors.length;
                } else if (pointCount === 0) {
                    ui.dispMargin.innerText = 'N/A';
                    ui.dispSVCount.innerText = '0';
                    ui.statusMessage.innerText = "상태: 데이터 입력 중 (최소 2개 필요)";
                }
            }
            
            // --- 이벤트 핸들러 ---
            function handleCanvasClick(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const p = toLogical(x, y);
                
                // 범위 제한
                if(Math.abs(p.x) > VIEW_RANGE || Math.abs(p.y) > VIEW_RANGE) return;
                
                dataPoints.push({ x: p.x, y: p.y, class: currentClass });
                
                // 안내 메시지 숨김
                if(dataPoints.length > 0) guideMsg.style.opacity = '0';

                // 데이터가 추가/변경되면 기존 결과 리셋
                resetSVMResult();
                updateUI();
                draw();
            }
            
            // --- 그리기 ---
            function draw() {
                // 초기화
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 1. 하이퍼플레인 및 마진 그리기
                const w = svmResult.w;
                const b = svmResult.b;
                const normW = norm(w);

                if (normW > 1e-5) {
                    // 경계선 그리기 (w*x + b = 0)
                    
                    const drawLine = (offset, color, isDashed = false) => {
                        ctx.beginPath();
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 2;
                        if (isDashed) ctx.setLineDash([5, 5]); else ctx.setLineDash([]);

                        let startX = -VIEW_RANGE;
                        let endX = VIEW_RANGE;
                        const maxY = VIEW_RANGE;
                        const minY = -VIEW_RANGE;
                        const maxX = VIEW_RANGE;
                        const minX = -VIEW_RANGE;
                        const bPrime = b + offset * normW;

                        if (Math.abs(w.y) > 1e-5) {
                            // 일반적인 경우 (y = mx + c)
                            const getLineY = (x) => (-w.x * x - bPrime) / w.y;
                            
                            let x1 = startX;
                            let y1 = getLineY(x1);
                            let x2 = endX;
                            let y2 = getLineY(x2);

                            // Helper to get X given Y, only usable if w.x is not near zero
                            const getLineX = (y) => (-w.y * y - bPrime) / w.x;

                            // 1. Clip against Y boundaries (adjusting X)
                            if (y1 > maxY || y1 < minY) {
                                y1 = y1 > maxY ? maxY : minY;
                                if (Math.abs(w.x) > 1e-5) x1 = getLineX(y1); 
                            }
                            if (y2 > maxY || y2 < minY) {
                                y2 = y2 > maxY ? maxY : minY;
                                if (Math.abs(w.x) > 1e-5) x2 = getLineX(y2);
                            }
                            
                            // 2. Clip against X boundaries (adjusting Y) - safety check
                            if (x1 > maxX || x1 < minX) {
                                x1 = x1 > maxX ? maxX : minX;
                                y1 = getLineY(x1);
                            }
                            if (x2 > maxX || x2 < minX) {
                                x2 = x2 > maxX ? maxX : minX;
                                y2 = getLineY(x2);
                            }
                            
                            let s1 = toScreen(x1, y1);
                            let s2 = toScreen(x2, y2);

                            ctx.moveTo(s1.x, s1.y);
                            ctx.lineTo(s2.x, s2.y);
                            
                        } else if (Math.abs(w.x) > 1e-5) {
                             // w.y가 0에 가깝거나 0인 경우 (거의 수직)
                            const getLineX = (y) => (-w.y * y - bPrime) / w.x;

                            let y1 = VIEW_RANGE;
                            let x1 = getLineX(y1);
                            let y2 = -VIEW_RANGE;
                            let x2 = getLineX(y2);

                            // Clip against X boundaries
                            if (x1 > maxX || x1 < minX) {
                                x1 = x1 > maxX ? maxX : minX;
                            }
                            if (x2 > maxX || x2 < minX) {
                                x2 = x2 > maxX ? maxX : minX;
                            }

                            let s1 = toScreen(x1, y1);
                            let s2 = toScreen(x2, y2);
                            
                            ctx.moveTo(s1.x, s1.y);
                            ctx.lineTo(s2.x, s2.y);
                        }
                        
                        ctx.stroke();
                        ctx.setLineDash([]); // 대시 상태 초기화
                    };
                    
                    // 마진 경계선 (+1)
                    drawLine(1.0, CLASS_COLORS['A'].bg, true); 
                    // 하이퍼플레인 (0)
                    drawLine(0, '#1e293b', false); // Slate-800
                    // 마진 경계선 (-1)
                    drawLine(-1.0, CLASS_COLORS['B'].bg, true);
                }

                // 2. 데이터 점
                dataPoints.forEach(p => {
                    const s = toScreen(p.x, p.y);
                    const color = CLASS_COLORS[p.class].bg;
                    const ringColor = CLASS_COLORS[p.class].ring;
                    
                    // 점
                    ctx.beginPath();
                    ctx.fillStyle = color;
                    ctx.arc(s.x, s.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 점 테두리
                    ctx.strokeStyle = ringColor;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                });
                
                // 3. 서포트 벡터 하이라이트
                svmResult.supportVectors.forEach(sv => {
                    const s = toScreen(sv.x, sv.y);
                    const color = CLASS_COLORS[sv.class].bg;
                    
                    // 서포트 벡터 주변에 굵은 빨간색 링 표시
                    ctx.beginPath();
                    ctx.strokeStyle = '#f87171'; // Red-400
                    ctx.lineWidth = 4;
                    ctx.arc(s.x, s.y, 9, 0, Math.PI * 2);
                    ctx.stroke();

                    // 내부 색상 (원래 클래스 색상)
                    ctx.beginPath();
                    ctx.fillStyle = color;
                    ctx.arc(s.x, s.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            // 실행
            init();
        })();
    </script>
</body>
</html>
